module generate

imports
	
	include/TypeSystemLanguage
	pp
  
rules 
 
  to-stratego(|project-path, modname) :
    Module(name, def*) ->
    $[module [modname]
    
      imports
        [import]
        
      rules
        [rule*]
        
      rules // projections
        [projection*]
    ]
    where rule* := <desugar-all; collect(rule-to-stratego)> def*
        ; projection* := <bagof-Projections>
        ; if <file-exists> $[[project-path]/lib/nabl/collect.str] then
            import := 
              $[lib/nabl/-
                lib/task/-
                lib/types/-
                lib/properties/-
               ]
          else
            import :=
              $[lib/runtime/nabl/-
                lib/runtime/task/-
                lib/runtime/types/-
                lib/runtime/properties/-
               ]
          end
   
rules // desugaring
  
  desugar-all = 
    innermost(desugar)
    ; label-formulas
    
  desugar :
    And(x, And(y, z)) -> And(And(x, y), z) 
    
  desugar :
    And(True(), p) -> p
    
  desugar :
    And(p, True()) -> p 
  
  desugar :
    TypeRuleUnCond(prop) -> TypeRule(prop, True())
      
  desugar :
    HasType(trm, pat) -> And(HasType(trm, Var(t)), Match(VarRef(t), pat))
    where <not(?Var(_))> pat; t := <newname> "t"
    
  desugar :
    ListVar(x) -> Var(<unstar>x)
    
  desugar :
    ListVarRef(x) -> VarRef(<unstar>x) 
    
  unstar = 
    explode-string; map(try(\ 42 -> 95 \)); implode-string
    
rules

  label-formulas =
    alltd(TypeRule(id, label-formula))
    
  label-formula :
    True() -> True()
    
  label-formula :
    Label(l, form) -> <label-formula> form
    
  label-formula :
    And(form1, form2) -> And(form1', form2')
    where form1' := <label-formula> form1
        ; form2' := <label-formula> form2

  label-formula :
    Or(form1, form2) -> Label(l, Or(form1', form2'))
    where form1' := <label-formula> form1
        ; form2' := <label-formula> form2   
        ; l := <newname> "or"    

  label-formula :
    Else(form, msg, target) -> Else(<label-formula>form, msg, target)

  label-formula :
    form@Has(trm, op, Var(t)) -> Label(t, form)
        
  label-formula :
    form@HasType(trm, Var(t)) -> Label(t, form)
    
  label-formula :
    form@SubType(trm1, op, trm2) -> Label(<newname> "subtype", form)
  
  label-formula :
    form@Eq(trm1, trm2) -> Label(<newname> "eq", form)
    
  label-formula :
    form@Match(VarRef(_), pat) -> form'
    where if <pattern-vars> pat => [] then
            form' := Label(<newname> "match", form)
          else
            form' := form
          end

  label-formula :
    form@Match(Combine(_,_), Var(x)) -> Label(x, form)
    
rules
	
	task-dependencies =
		collect(?Label(<![<id>]>, _) <+ ?Match(_, <pattern-vars>)); concat; make-set
		
  pattern-vars =
  	collect(?Var(<id>))
			     
rules // conditional rule
  
  rule-to-stratego :
    TypeRule(HasTypePat(pat, trm), form) -> $[
      create-type-task(|ctx) :
        [<term-to-stratego>pat] -> <type-is(|ctx, $[$[deps]$]$)> [<term-to-stratego>trm]
        where [s]
    ] 
    where (_, s) := <formula-to-stratego> form
        ; deps := <task-dependencies; separate-by(|", "); concat-strings> form

  rule-to-stratego :
    TypeRule(HasPat(pat, op, VarRef(x)), form) -> $[
      create-[op]-task(|ctx) :
        [<term-to-stratego>pat] -> [l]
        where [s]
    ]
    where (l, s) := <formula-to-stratego> form
        ; deps := <task-dependencies; separate-by(|", "); concat-strings> form
          
  // todo: target for WF rules
  rule-to-stratego :
    TypeRule(IsWF(pat), form) -> $[
      nabl-constraint(|ctx) :
        [<term-to-stratego>pat] -> <fail>
        where [s]
    ]
    where (_, s) := <formula-to-stratego> form
        ; deps := <task-dependencies; separate-by(|", "); concat-strings> form

  rule-to-stratego :
    TypeRule(SubTypePat(pat1, op, pat2), form) -> $[
      create-subtype-task(|ctx) :
        ("[op]", [<term-to-stratego>pat1], [<term-to-stratego>pat2]) -> [dep]
        where [s]
    ]
    where (dep, s) := <formula-to-stratego> form
        ; deps := <task-dependencies; separate-by(|", "); concat-strings> form
                    
rules // formula
      
  formula-to-stratego :
    True() -> ("", $[id])
    
  formula-to-stratego :
    And(form1, form2) -> 
      (t2, $[[s1];
             [s2]])
    where (t1, s1) := <formula-to-stratego> form1
        ; (t2, s2) := <formula-to-stratego> form2

  formula-to-stratego :
    Label(l, Or(form1, form2)) -> 
      (l, $[[s1];
            [s2];
            [l] := <new-task(|ctx)> Choice($[$[t1],[t2]$]$)])
    where (t1, s1) := <formula-to-stratego> form1
        ; (t2, s2) := <formula-to-stratego> form2
        //; t3 := <newname> "task"
        
  formula-to-stratego :
    Else(form, msg, target) -> 
      (t, $[[s];
            <task-create-error-on-failure(|ctx, [t], [<term-to-stratego>msg])> [<term-to-stratego>target]])
    where (t, s) := <formula-to-stratego> form
            
  formula-to-stratego :
    Label(l, HasType(VarRef(x), Var(t))) -> 
      (t, $[[t] := <type-task(|ctx)> [x]])

  formula-to-stratego :
    Label(l, Has(VarRef(x), attr, Var(t))) -> 
      (t, $[[t] := <[attr]-lookup(|ctx)> [x]])
      
  formula-to-stratego :
    Label(l, Has(DefOf(trm), op, Var(t))) -> 
      (t, $[[t] := <[op]-lookup(|ctx)> [<term-to-stratego>trm]])
                   
  formula-to-stratego :
    Label(l, HasType(DefOf(trm), Var(t))) -> 
      (t, $[[t] := <type-lookup(|ctx)> [<term-to-stratego>trm]])
            
  formula-to-stratego :
    Label(l, SubType(trm1, op, trm2)) ->
      (l, $[[l] := <create-subtype-task(|ctx)>("[op]", [<term-to-stratego>trm1], [<term-to-stratego>trm2])])
 
  formula-to-stratego :
    Label(l, Eq(trm1, trm2)) -> 
      (l, $[[l] := <type-match(|ctx, [<term-to-stratego>trm2])> [<term-to-stratego>trm1]])

  formula-to-stratego :
    Match(VarRef(x), pat) -> (<Hd> ys, strat)
    where
      ys := <pattern-vars> pat;
      strat := <map(mk-projection(|x, pat)); separate-by(|";\n")> ys
      
  formula-to-stratego :
    Label(l, Match(VarRef(x), pat)) -> (l, $[[l] := <new-task(|ctx)> Rewrite("[rl]", [x])])
    where
      [] := <pattern-vars> pat;
      rl := <newname> "match";
      r := $[
        task-rewrite :
          ("[rl]", x@[<term-to-stratego>pat]) -> x
      ];
      rules( Projections :+ _ -> r)
      
  formula-to-stratego :
    Label(l, Match(Combine(trm1, trm2), Var(x))) -> 
      (l, $[[x] := <new-task(|ctx)> Combine($[$[<term-to-stratego>trm1], [<term-to-stratego>trm2]$]$)])
            
   mk-projection(|x, pat) :
     y -> $[[y] := <new-task(|ctx)> Rewrite("[rl]", [x])]
     where rl := <newname> "proj"
         ; r := $[
             task-rewrite :
               ("[rl]", [<term-to-stratego>pat]) -> [y]
           ]
         ; rules( Projections :+ _ -> r )

rules // term
  
  term-to-stratego :
    Var(x) -> x
    
  term-to-stratego :
    VarRef(x) -> x

  term-to-stratego :
    ListVar(x) -> x
    
  term-to-stratego :
    ListVarRef(x) -> x
        
  term-to-stratego :
    Int(i) -> i
    
  term-to-stratego :
    Real(r) -> r
    
  term-to-stratego :
    Str(s) -> s

  term-to-stratego :
    Char(s) -> s
        
  term-to-stratego :
    Op(cns, t*) -> $[[cns]([<map(term-to-stratego); separate-by(|", ")> t*])]
    
  term-to-stratego :
    OpQ(cns, t*) -> $["[cns]"([<map(term-to-stratego); separate-by(|", ")> t*])]
            
  term-to-stratego :
    Tuple(t*) -> $[([<map(term-to-stratego); separate-by(|", ")> t*])]

  term-to-stratego :
    List(t*) -> $<[<<map(term-to-stratego); separate-by(|", ")> t*>]>
    
  term-to-stratego :
    ListTail(t*, t) -> $<[<<map(term-to-stratego); separate-by(|", ")> t*> | <<term-to-stratego>t>]>
  
  // term-to-stratego :
  //   DefOf(ns, trm) -> $[<type-lookup(|ctx)> [<term-to-stratego> trm]]


            

        

    