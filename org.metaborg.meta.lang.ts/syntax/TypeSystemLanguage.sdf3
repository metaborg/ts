module TypeSystemLanguage

imports 
  common/Identifiers   
  common/Layout 
  terms/Terms
  terms/Vars
  Module
  Signatures
  TypeFunctions
  Relations
  PP

context-free start-symbols Module

templates

  // TsModule.Module = <
  //   module <Id> 
  //     <TypeRules*; separator="\n\n">
  // >  

  ModuleSection.TypeRules = <
    type rules
    
      <TypeRule*; separator="\n\n">
    >

  TypeRule.TypeRuleUnCond = 
    <<PropPattern>>

  TypeRule.TypeRule = <
    <PropPattern>
    where <Formula>
    >

templates // formulas

  Formula = <<Prop>>

  Formula.Else = <
    <Formula> else error <Term> on <Term>
  > {left} 
  
  Formula.Not = <
    not <Formula>
  >
    
  Formula.Or = <
    <Formula> 
    or <Formula>
  > {assoc}
     
  Formula.And = <  
    <Formula> 
    and <Formula> 
  > {assoc}
  
  Formula.Label = <
    <LId> :: <Formula>
  >
  
  Formula = <(<Formula>)> {bracket}

templates // instructions

  Formula.Is = <[<Instruction*; separator="\n">]> 
     
  Instruction.I = <<Formula>;>  
  
  Instruction.Id = <<Formula> provided <VarRef>;>  
  
  Instruction.Ia = <<Var> := <Formula>;>  
  
  Instruction.Iad = <<Var> := <Formula> provided <VarRef>;> 
    
context-free priorities

   Formula.Label > Formula.Not > Formula.Else > Formula.And > Formula.Or
   
templates // propositions
  
  Prop.True         = <true>
  Prop.False        = <false>
  Prop.HasType      = <<Term> : <Pattern>>
  Prop.Has          = <<Term> has <Id> <Pattern>>  
  Prop.Eq           = [[Term] == [Term]] 
  Prop.Match        = [[Term] => [Pattern]]
  
  Prop.Bind         = [[Term] bind [Var]]
  Prop.Project      = [[VarRef] project [Pattern]] // at most one Var in Pattern
  
  Prop.Return       = [return [Term]]
  
templates // proposition patterns
   
  PropPattern.HasTypePat = <<Pattern+; separator=" + "> : <Term>>
  PropPattern.HasPat     = <<Pattern+; separator=" + "> has <Id> <Term>>
  PropPattern.IsWF       = <<Pattern+; separator=" + "> :->
     
templates // term operators

  Term.DefOf   = <definition of <Term>> 
  Term.Choice  = <<Term> or <Term>>     {assoc}
  Term.Union   = <<Term> union <Term>>  {assoc}
  
context-free priorities

   Term.DefOf > Term.Choice > Term.Union

templates // keywords

  Id = <where> {reject}
